import matplotlib.pyplot as plt
import matplotlib.animation as animation
import numpy as np
import scipy as sp


###########################################################
####  PLOT STUFF ####################################### 

fig, ((ax0, ax1), (ax2, ax3)) = plt.subplots(2, 2)

###########################################################
####  FORMULA STUFF ####################################### 

class Environment():
    def __init__(self, altitude, temperature):
        self.altitude = altitude
        self.temperature = temperature

class Machine():
    def __init__(self, name, wattage, weight, Battery):
        self.name = name
        self.wattage = wattage
        self.weight = weight
        self.Battery = Battery
        
class Battery():
    def __init__(self, capacity, charge_rate, weight):
        self.capacity = capacity
        self.charge_rate = charge_rate
        self.weight = weight
        # Temperature dependency

# Nested temperature control should affect the battery
# Perhaps model the box around the battery

class Stretch():
    def __init__(self, start, stations, end):
        self.start = start
        self.stations = stations
        self.end = end

class Place():
    def __init__(self, name, distance_from_last, altitude):
        self.name = name
        self.distance_from_last = distance_from_last
        self.altitude = altitude


## Initializer function to populate the simulation
def populate():
    start = Place('First Station',0, 112)
    s_01 = Place('Stasjon1',4.00, 100)
    s_02 = Place('Stasjon2',5.00, 124)
    s_03 = Place('Stasjon3',3.00, 114)
    s_04 = Place('Stasjon4',2.00, 98)
    s_05 = Place('Stasjon5',1.00, 102)
    s_06 = Place('Stasjon6',6.00, 121)
    s_07 = Place('Stasjon7',3.00, 119)
    s_08 = Place('Stasjon8',2.00, 110)
    s_09 = Place('Stasjon9',6.00, 111)
    end = Place('End Station',8.00, 122)
    destination = [start,s_01,s_02,s_03,s_04,s_05,s_06,s_07,s_08,s_09,end]
    return destination

def get_stretch(destination_list, duration):
    names = []
    distances = []
    altitudes = []
    distance_sum = 0
    for destination in destination_list:
        names.append(destination.name)
        distance_sum = distance_sum + destination.distance_from_last
        distances.append(distance_sum)
        altitudes.append(destination.altitude)
    
    #print(distances)
    distances_interpolated = expand_array(distances, duration)
    #print(distances_interpolated)

    return [names, distances, altitudes]

## Function modified from one generated by ChatGPT
def expand_array(input_array, length):
    """
    Expands an input array to a desired length by linearly interpolating the points in between.

    Args:
    input_array (numpy.ndarray): A 1D array of shape (N,) containing the input data.
    length (int): The desired length of the output array.

    Returns:
    numpy.ndarray: A 1D array of shape (length,) containing the expanded data.
    """
    # Get the number of points in the input array
    n = input_array.shape[0]

    # Create an array of indices corresponding to the input points
    indices = np.arange(n)

    # Create an array of indices corresponding to the output points
    new_indices = np.linspace(0, n - 1, length)

    # Interpolate the input data at the output points
    output_array = np.interp(new_indices, indices, input_array)

    return output_array

def simulate(duration, Machine, Battery, Environment):
    m = Machine
    b = Battery
    e = Environment

    w = Machine.wattage
    t = 0
    temp = Environment.temperature
    alt = Environment.altitude

    x_0, y_0, y_1, y_2, y_3 = [], [], [], [], []


    charge=0

    while t<duration:

        temp = temp + np.random.randint(-1,2)
        alt = alt + np.random.randint(-1,2)

        x_0.append(t)
        y_0.append(m.wattage + 2*temp + charge)


        if m.wattage < 250:
            charge = 500

        if charge > 0:
            charge = charge-10
        
        y_1.append(alt)
        y_2.append(temp)
        y_3.append(charge)
        t = t+1

        # Making some random temperature & height variations; replace with data
        # TODO: Can also plot altitude and temperatures

        m.wattage = m.wattage - 2
        
        
        
        if(m.wattage<0):
            m.wattage=0
        elif(m.wattage>1000):
            m.wattage=1000


    # Create the plot
    ax0.plot(x_0,y_0)
    ax0.set(xlabel='Time [m]', ylabel='Capacity [kWh]')

    ax1.plot(x_0,y_1, 'tab:orange')
    ax2.plot(x_0,y_2, 'tab:green')
    ax3.plot(x_0,y_3, 'tab:red')


def battery_depletion(E0, k, t, T, Ea, A):
    """
    Calculates the remaining energy in a battery as a function of time and temperature,
    assuming an exponential decay model with temperature dependence.

    Parameters:
    E0 (float): the initial energy of the battery
    k (float): the decay constant, in units of inverse time
    t (numpy array): an array of time values at which to evaluate the energy
    T (float or numpy array): the temperature of the battery, in Kelvin
    Ea (float): the activation energy, in units of energy per mole
    A (float): the pre-exponential factor, in units of inverse time

    Returns:
    E (numpy array): an array of energy values corresponding to the input time and temperature arrays
    """
    R = 8.314  # gas constant, in units of J/mol/K

    #
    # In this version of the function, we have added three new parameters:

    #T: the temperature of the battery, in Kelvin
    #Ea: the activation energy, which describes the dependence of the decay constant on temperature
    #A: the pre-exponential factor, which is another parameter that describes the temperature dependence of the decay constant.
    #The formula for the remaining energy now includes an additional term that depends on temperature, which is given by A * exp(-Ea/(R*T)), #where R is the gas constant in units of J/mol/K. This term describes the temperature dependence of the decay constant k, and accounts for #the fact that batteries tend to lose energy more quickly at higher temperatures due to increased chemical and electrochemical reactions.

    #Note that the activation energy Ea and pre-exponential factor A are specific to each battery chemistry and geometry, and can be estimated #from experimental data or literature values.

    E = E0 * np.exp(-A * np.exp(-Ea/(R*T)) * t - k * t)
    return E

def deplete(Machine, Environment):
    alt = Environment.alt()
    reduced_w = 50*(alt/100)
    return -reduced_w

## charging function returning the charged wattaged #TODO: Override where you can charge for a set cap, returning time
def charge(current_wattage, time_to_charge, temperature, alt):
    charge_rate = 10*temperature/100
    increased_w = time_to_charge*charge_rate
    return increased_w

def run():
    m = Machine('LT15',1000,7000,'Li-ion')
    b = Battery(100,10,500)
    e = Environment(110,15)
    duration = 720

    #get_stretch(populate(), duration)

    simulate(duration, m,b,e)
    plt.show()

run()